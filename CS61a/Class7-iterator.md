# Class7-iterator

## 1. 基本概念

- **容器与迭代器**
  - **容器（Iterable）**：数据结构（例如列表、字典等）能够提供对其元素的迭代访问。
  - **迭代器（Iterator）**：一种对象，它在遍历容器时记录当前位置，并能依次返回容器中的下一个元素。

## 2. 创建迭代器

- 使用内置的 `iter()` 函数来创建迭代器：
  - 示例：
    ```python
    lst = [1, 2, 3]
    it = iter(lst)  # 创建一个迭代器
    ```

## 3. 获取下一个元素

- 使用 `next()` 函数从迭代器中获取下一个元素：
  - 示例：
    ```python
    print(next(it))  # 输出 1
    ```
  - **说明**：每次调用 `next()` 都会让迭代器内部的指针前进一位，从而访问下一个元素。

## 4. 迭代器与序列的位置

- 可以将迭代器看作是“指针”，指向序列中的某个位置，并从该位置开始逐一访问剩余元素。
- 每次调用iterator时，迭代器的内部状态（即当前位置）会更新，而元素本身不变。

## 5. 字典的迭代

- 字典可以通过迭代获得：
  - 键（默认迭代字典时）
  - 值（通过 `dict.values()`）
  - 键值对（通过 `dict.items()`）
- **注意**：
  - 字典中键值对的顺序通常是按照插入顺序（Python 3.7 及以后版本保证这一点）。
  - 修改字典的大小（添加或删除键）会使现有的迭代器失效；而修改值不会影响迭代器。

## 6. for 语句与迭代器

- `for` 循环会自动调用迭代器的 `next()` 方法，直到迭代结束。
- 当用 `for` 循环迭代一个**迭代器**时，迭代器内部的状态会不断前进；但如果直接对可迭代对象（例如列表）使用 `for`，内部会隐式创建一个新的迭代器，因此不会影响原有对象的状态。

## 7. 内置函数与惰性计算

- 许多内置的序列处理函数返回的是**迭代器**，以便进行惰性（lazy）计算：
  - **map**: 
    - 用法：`map(func, iterable)`
    - 作用：返回一个迭代器，每次对迭代器中的元素调用 `func` 计算结果。
  - **zip**:
    - 用法：`zip(iterable1, iterable2, ...)`
    - 作用：返回一个迭代器，其每个元素都是一个元组，包含来自各个输入迭代器对应位置的元素。
  - **filter**:
    - 注意：内置 `filter()` 返回的是一个迭代器，包含所有使给定函数返回 `True` 的元素。
    - 返回包含所有符合条件的元素的迭代器。

- **惰性计算**：允许程序在需要时才计算值，适用于处理大量数据。

## 8. zip 函数示例

- 示例代码：
  ```python
  result = list(zip([1, 2], [3, 4]))
  print(result)  # 输出 [(1, 3), (2, 4)]

​	•	如果其中一个迭代器比另一个短，则 zip 只会迭代到最短的那个长度。

​	•	也可以对多个迭代器进行 zip 操作。

​	•	**取元组方式**：例如，可以使用 for x, y in zip(s, reversed(s)) 来同时遍历序列及其反向版本。

## **9. 迭代器的应用**

​	•	**数据抽象**：使用迭代器可以将数据的表示从列表转换为其他形式（例如元组），而无需改变代码逻辑。

​	•	**统一处理**：通过迭代器可以统一处理不同类型的大量数据，保证每个元素只被处理一次，并且能将序列及其当前状态（即目前iterator指向的位置）封装在一个对象中，传递给其他函数使用。