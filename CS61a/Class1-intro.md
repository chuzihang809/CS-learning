# CS61a

函数式编程，利用函数表达任何表达式

函数表达式形式

```python
max(1,2,3) //函数名字加上参数
```

表达式的嵌套**直接决定计算顺序**

表达式由运算符和操作数组成，他们也是表达式。

调用表达式的求值过程是先评估运算符，再逐个评估操作数

如图，分开单独评估，类似递归树![微信图片_20250118160917](C:\Users\Oscar\Desktop\学习资料\微信图片_20250118160917.png)

## 定义函数的方式

1. 调用库中的已知函数 from *库名* import *函数名*

   ```python
   from operator import add, sub
   print(sub(2,1))
   ```
   
   


2. 在程序中定义 def  *函数名* (参数1，参数2)：末尾加return

   ```python
   def a_plus_abs_b(a, b):
       if b < 0:
           f = sub
       else:
           f = add
       return f(a, b)

3. 直接对**函数赋名** f=add 将add函数赋值给f函数

   ```python
   f=add
   print(f(3,5)) //此时输出结果为8！
   
   ```

## 表达式的类型

### 基本表达式

包括数值，名字（运算符），字符串

### 调用表达式

由运算符，操作数（非必须）组成。可以嵌套！

## 环境图

作用是展示python解释器的进程

由代码和框架组成，框架的作用是跟踪值和名字的绑定过程

对框架而言：

1. 每个名字都被绑定到一个值
2. 在一个框架内，名字不能重复，只能被绑定到一个值

## 赋值语句

改变框架中名字和值的绑定

赋值规则：

1. 从左到右计算**等号右边**所有表达式 ==先算右边！！==
2. 将等号左边所有名字绑定到右边的表达式结果

示例：

```python
a=1
b=2
b,a=a+b,b
```

赋值规则应用：计算右边表达式值为3，2，分别赋给左边的b,a,最后b=3,a=2

## 定义函数

赋值是一种普通的抽象方式，将值与名字绑定。函数是强大的抽象方式，将**整个表达式和一系列语句绑定到名字**

```python
def <name>(<形式参数>): //这一行被称为函数签名，用于表明函数需要多少个参数
   main body //决定函数功能
  return <return expression>
```

### 定义函数过程

1. 遇到`def`关键字时：在全局环境中创造包含着函数签名的函数

2. 设置函数主体main body，第一行后的所有内容

   设置时**并没有对主体进行任何运行！**，函数体暂时被保存起来，调用时才实际执行主体

3. 在当前框架中将给定名称绑定到函数上

## 调用用户定义的函数过程

函数签名为本地框架的建立提供信息，具体来说，函数名为框架提供名字，而形式参数则为框架提供了需要绑定的名字

1. 添加局部框架，形成新环境
2. 在局部框架中将实际参数与形式参数绑定
3. 在创建的新环境中执行函数主体

以下是函数定义和调用过程的环境图![6ae5791203a54f4f98f22a047e4841f](C:\Users\Oscar\Desktop\学习资料\6ae5791203a54f4f98f22a047e4841f.png)

## 在环境中查找名字

对每个表达式求值的过程是存在于环境的上下文的

环境是用于跟踪name和value对应关系的，环境实际上”知道“name所对应的值

### 最重要的两点

1. 环境是由一系列frame组成的，而这一系列frame实际上是有其顺序的，frame是name和value的绑定关系

2. 当评估name对应的value时，评估的实际上是在一系列有顺序的frame中最早找到的那个name

==这里的顺序是内建的顺序，有如下的查找规则==

> **当前局部作用域（Local）**：
> 首先检查当前函数或代码块内是否定义了这个名字。如果找到，就使用这个名字对应的值。
>
> **外层嵌套作用域（Enclosing）**：
> 如果当前局部作用域没有找到，会检查外层嵌套的函数作用域（如果存在）。
>
> **全局作用域（Global）**：
> 如果嵌套作用域也没有找到，就检查全局作用域中是否有这个名字。
>
> **内建作用域（Built-in）**：
> 如果全局作用域中没有找到，最后检查 Python 内建作用域（如内置函数 `len`、`sum` 等）。

同时，重要的一点是，**局部作用域会被销毁**，示例：

```python
x = 10  # 全局变量

def outer():
    x = 20  # 外层函数的局部变量

    def inner():
        x = 30  # 内层函数的局部变量
        print(x)  # 输出 30（当前局部作用域）

    inner()

outer()
print(x)  # 全局作用域中的 x

```

在print()函数输出的时候，**局部的作用域已经被销毁**，现在我们**位于全局的作用域**，所以我从全局作用域中查找x的值，发现是10，因此输出10
